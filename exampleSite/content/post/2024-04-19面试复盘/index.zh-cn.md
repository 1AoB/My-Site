+++
author = "Wxn"
title = "2024-04-19面试复盘"
date = "2024-04-19"
description = "Please read me first."
tags = [
	"Dilay",
]
categories = [
    "面试复盘",
]

+++

This article offers a sample of basic Markdown.
<!--more-->

# 正文开始

1.struct和class的区别

2.值传递，地址传递，引用传递（拷贝）的区别

4.指针是几个字节？

5.static关键字

6.虚函数指针，虚函数表

7.多态

8.编译器如何知道你是进行的函数重载

答：函数重载，它允许在同一个作用域中定义多个同名函数，但这些函数的<font color=red>参数列表或类型</font>必须不同。在调用这些函数时，编译器会根据传递给<font color=red>函数的参数的数量、类型或顺序</font>来确定要调用的具体函数版本。

简单来讲，就是函数重载可以是<font color=red>参数类型不同，参数顺序不同，也可以是参数个数不同</font>

编译器会在内部，把函数名称和参数列表一起存储在符号表中，这样编译器就知道了你用的是哪个重载之后的函数

就是，编译器在处理函数重载时，会将函数名称和参数列表一起存储在符号表（或类似符号表的数据结构）中。这样编译器就能够确定每个函数的唯一签名，并且在需要进行函数调用匹配时可以快速检索并确定调用哪个函数版本。



9.构造，析构的顺序

在C++中，对象的构造和析构顺序

最主要是

和对象的创建和销毁顺序相关。

一般情况下，<font color=red>对象的构造顺序与对象的创建顺序相同，对象的析构顺序与对象的销毁顺序相反。</font>

比如说，如果一个类 `A` （包含类 `B` 和类 `C` 的对象作为成员），则在创建 `A` 的对象时，首先会调用 `B` 的构造函数，然后调用 `C` 的构造函数。

然后析构顺序就与构造顺序相反。也就说当销毁对象A时，析构函数会按照对象在类成员<font color=red>声明</font>中的逆序依次调用。继续上面的例子，也就是说，他首先会调用 `C` 的析构函数，然后调用 `B` 的析构函数。



还有一种情况：就是父类和子类的析构与构造关系：

比如说现在有一个子类b,他继承了父类a,那么在创建子类b的对象时,

就会先调用父类a的构造函数,

再调用自己子类b的构造函数,

在析构的时候,顺序就反过来了,

就是先析构子类b,

最后再析构父类a

```cpp
Base::fun()
Child::fun()
~Child::fun()
~Base::fun()
```



10.stl：vector、list、Map的区别

11.智能指针

智能指针有auto_ptr，share_ptr，unique_ptr还有shared_ptr

auto_ptr是C++98中引入的第一个智能指针，但是由于他的不安全性已被C++11弃用。他其实被unique_ptr给取代了,可以理解为auto_ptr他其实是一个浅拷贝,非常容易造成多个指针指向同一块内存区域的现象，这就引发非常多的潜在的问题:比如一些常见的段错误,多次析构,访问一段未定义的空间等,比如说你在文件中访问这个指针,但是其实你已经在其他地方释放这段内存了.

然后,unique_ptr 他提供了独占所有权的智能指针，允许有且仅有一个 `unique_ptr` 拥有资源。与 `auto_ptr` 不同，`unique_ptr` 实现了更安全和更完整的独占所有权语义

然后,shared_ptr,他允许多个指针共享同一块内存，<font color=red>并且会在最后一个 shared_ptr 被销毁时释放这段内存</font>。它使用的是一种引用计数的技术来追踪资源的所有者数量，并在所有者数量为零时自动释放资源。

然后最后一个,是weak_ptr: 他是 `shared_ptr` 的伴侣类，它允许你共享资源但不拥有资源。weak_ptr 不会增加引用计数,它通常用于解决 `shared_ptr` 的循环引用问题。



循环引用的问题:

然后循环引用通常是shared_ptr互相引用造成的,两个或多个对象相互持有对方的 shared_ptr，导致它们的引用计数永远不会降为零，然后导致资源泄漏。
我想到的一个例子是，比如说有一个双向列表，他们的每个节点对象都有两个指针,一个是前指针prior pointer，一个是next指针，

然后两个相邻的节点对象，节点1的next指针指向节点2自身，节点2的前指针prior pointer指向节点1自身，然后这两个节点都用share_ptr进行创建,在创建时,节点自身这段内存引用计数+1,然后被相邻指针指向时,引用计数再+1,这样每个节点的引用计数就都是2,

然后当我们销毁节点这个share_ptr后,前后节点的引用计数都降为了1,但是前节点在等着后节点的prior pointer放手,后节点在等着前节点的next pointer放手,这就形成了死锁,

造成的现象就是这两个节点的指针已经被销毁了,但是节点的内存迟迟无法析构,就造成了"内存泄漏",解决的办法就是把这个节点的prior指针和next指针都变成weak_ptr



12.项目中如何保证线程安全？

13.死锁

14.多线程中多个信号与主线程